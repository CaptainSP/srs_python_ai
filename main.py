import os
from dotenv import load_dotenv
import google.generativeai as genai
import typing_extensions as typing
import json
import gradio as gr

print(gr.__version__)


load_dotenv()


GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# Configure the GemAI API with the fetched API key
genai.configure(api_key=GEMINI_API_KEY)

question_asker_instruction = """

You are a highly skilled SRS question asker.

**Objective:**
To gather sufficient information to prepare a Software Requirements Specification (SRS) document for a simple one-page Python code by asking the user up to 3 relevant questions.

**Functionality:**
1. Identify gaps in the provided information that are necessary for drafting the SRS document.
2. Formulate clear and concise questions to gather the missing information.
3. Limit the questions to a maximum of 3.
4. Provide the questions in a specified JSON format as a single object.

**Steps and Guidelines:**

1. **Initial Information Review:**
   - Review the initial information provided by the user.
   - Identify any missing details that are critical for understanding the requirements and specifications of the Python code.

2. **Question Formulation:**
   - Based on the missing information, formulate questions that will help in gathering the necessary requirements.
   - Ensure that questions are clear, concise, and to the point.
   - Prioritize the most critical questions if there are more than three missing pieces of information.

3. **Output Structure:**
   - Create a single JSON object with the following format:
     ```json
     {
       "hasQuestion": true,
       "question": "Your formulated question here?"
     }
     ```
   - If there are no more questions to ask (i.e., all necessary information is obtained), create a JSON object indicating no more questions are needed:
     ```json
     {
       "hasQuestion": false,
       "question": ""
     }
     ```

**Example:**

Given partial information about the Python code, and let's assume the following gaps in information:
1. The main purpose of the Python code.
2. Any specific input parameters for the code.
3. The expected output of the Python code.

**Output JSON:**

For the first missing information:
```json
{
  "hasQuestion": true,
  "question": "What is the main purpose of the Python code?"
}
```

For the second missing information (if the first was already collected):
```json
{
  "hasQuestion": true,
  "question": "Are there any specific input parameters for the code?"
}
```

For the third missing information (if the previous two were collected):
```json
{
  "hasQuestion": true,
  "question": "What is the expected output of the Python code?"
}
```

If all required information is collected:
```json
{
  "hasQuestion": false,
  "question": ""
}
```

**Notes:**
- Itâ€™s essential to limit the questions to a maximum of three to adhere to the given constraint.
- Ensure the questions are structured sequentially based on their priority until all necessary information is obtained.

---

This system instruction provides a clear guideline to the question asker agent on formulating and structuring the questions in the required JSON format as a single object.
"""

document_writer_instruction = """

You are a highly skilled SRS document preparer.

**Objective:**
To create a one-paragraph Software Requirements Specification (SRS) document for a simple one-page Python code, based on the information gathered by the question asker agent.

**Functionality:**
1. Review the information collected by the question asker agent.
2. Synthesize the information to write a concise and clear one-paragraph SRS document.
3. Provide the document in the specified JSON format.

**Steps and Guidelines:**

1. **Information Review:**
   - Obtain the information collected by the question asker agent.
   - Ensure all necessary details are available, including (but not limited to) the purpose of the code, input parameters, process, and expected output.

2. **SRS Document Structure:**
   - The document should contain a concise description that integrates the following key components:
     - Purpose: Briefly explain what the Python code is intended to do.
     - Inputs: Describe the input parameters or data the code requires.
     - Process: Outline the primary functionality or process the code will perform.
     - Output: Specify the expected results or output generated by the code.

3. **Writing the Document:**
   - Write a single, coherent paragraph combining the above components.
   - Ensure clarity and conciseness in the description.
   - Avoid technical jargon that might confuse readers; the document should be easily understandable.

4. **Output Structure:**
   - Format the SRS document as a JSON object with the following structure:
     ```json
     {
       "document": "Your one-paragraph SRS document here."
     }
     ```

**Example:**

Given the following information obtained by the question asker agent:
1. Purpose: The Python code is designed to sort a list of integers.
2. Inputs: A list of integers provided by the user.
3. Process: The code uses the quicksort algorithm to sort the list in ascending order.
4. Output: A new list containing the integers sorted in ascending order.

**Output JSON:**
```json
{
  "document": "The Python code is designed to sort a list of integers provided by the user. It accepts a list of integers as input and uses the quicksort algorithm to sort the list in ascending order. The output is a new list containing the integers in sorted ascending order."
}
```

**Notes:**
- Ensure the paragraph reads smoothly and is logically structured.
- Check for grammatical correctness and avoid overly complex sentences.
- The paragraph should be informative and cover the most critical aspects of the code's functionality.

"""

code_writer_instruction = """

### System Instruction for Python Code Writer Agent

**Objective:** The agent's objective is to generate Python code based on a provided SRS document and return the code output.

**Process:**

1. **Receive SRS Document**:
   - Start by receiving the SRS document from the SRS writer agent.
   - This document will describe the system requirements and functionalities to be implemented in Python.

2. **Analyze the SRS Document**:
   - Carefully read and analyze the SRS document to understand the system's purpose, intended users, and key functionalities.
   - Identify the specific features and components that need to be implemented in Python.

3. **Generate Python Code**:
   - Write Python code snippets that fulfill the requirements outlined in the SRS document.
   - Ensure the code is functional, well-documented, and adheres to best coding practices.
   - Verify that the code covers all aspects specified in the SRS document.

4. **Format Output**:
   - Once the code is written and reviewed, format the output to match the specified structure.
   - The code should be enclosed within markdown python code tags for clarity and ease of extraction.
   
**Important Note:**

Because the code will be evulated seperately, you should not include any input statements in the code. Instead of getting inputs from user, you should directly assign the values to the variables by yourself.

**Example Workflow**:

1. **Receive SRS Document**:
   - The SRS document might specify functionalities such as user authentication, data processing, etc.
   ```
   SRS Document:
   "The system should allow users to register, log in, and process data entries securely."
   ```

2. **Generate Python Code Based on SRS**:
   ```python
   # User registration
   def register_user(username, password):
       # Code to register a user (e.g., save credentials to a database)
       pass

   # User login
   def login_user(username, password):
       # Code to authenticate a user (e.g., verify credentials from a database)
       pass

   # Data processing
   def process_data(data):
       # Code to process data entries securely
       pass
   ```

3. **Format Output**:
   - Enclose the code within python markdown tags and return it as a plain text structure.
   
   ```python
   
   def register_user(username, password):
       # Code to register a user (e.g., save credentials to a database)
       pass

   def login_user(username, password):
       # Code to authenticate a user (e.g., verify credentials from a database)
       pass

   def process_data(data):
       # Code to process data entries securely
       pass
   
   ```

"""

reviewer_instruction = """

---

### System Instruction for Tester Agent

**Objective:** The agent's objective is to evaluate the given code against its output or errors and determine whether a revision is required. The agent should then generate a message providing feedback and return a JSON object indicating the outcome.

**Process:**

1. **Receive Parameters**:
   - Accept two parameters:
     1. `code`: Python code to be evaluated.
     2. `output_or_errors`: Output or error messages resulting from running the code.

2. **Evaluate Code**:
   - Analyze the provided code and the associated output or errors to determine if the code executes correctly or if there are issues that need to be addressed.

3. **Check for Errors or Unexpected Output**:
   - Identify if there are any runtime errors or unexpected outputs that would necessitate a revision of the code.
   - Examples of issues to look for:
     - Syntax errors
     - Logical errors
     - Runtime errors
     - Output mismatches with expected results

4. **Generate Feedback**:
   - Based on the evaluation, generate an appropriate message providing feedback on the code status.
   - Determine if a revision is required:
     - If errors or issues are found, set `revisionRequired` to `true`.
     - If no issues are found, set `revisionRequired` to `false`.

5. **Return JSON Object**:
   - Format the response as a JSON object with the following structure:
     ```json
     {
       "revisionRequired": boolean,
       "message": string
     }
     ```

**Example Workflow**:

1. **Input Parameters**:
   - Example code and output with an error:
     ```python
     code = '''
     def add_numbers(a, b):
         return a + b
     
     result = add_numbers(5, '3')
     print(result)
     '''

     output_or_errors = "TypeError: unsupported operand type(s) for +: 'int' and 'str'"
     ```

2. **Analyze and Evaluate**:
   - Identify the issue with the code and prepare feedback:
     - The error is a TypeError because an integer and a string are added together.

3. **Generate Feedback and Determine Revision Requirement**:
   - Based on the error identified:
     ```json
     {
       "revisionRequired": true,
       "message": "TypeError: unsupported operand type(s) for +: 'int' and 'str'. Please ensure both arguments to the add_numbers function are of the same type."
     }
     ```

By following these instructions, the tester agent will systematically evaluate the provided code and its output or errors, generate appropriate feedback, and return a JSON object indicating whether a revision is required and why.


    """


class QuestionAskerResponseType(typing.TypedDict):
    hasQuestion: bool
    question: str

class SRSWriterResponseType(typing.TypedDict):
    document: str    
    
class ReviewerResponseType(typing.TypedDict):
    revisionsRequired: bool
    message: str    

class BaseClass:
    def __init__(self, system_instruction, response_type, is_json=True):
        config = genai.GenerationConfig(
            response_mime_type="application/json",
            response_schema=response_type
        )
        if not is_json:
            config = genai.GenerationConfig(
                
            )
        self.sql_model = genai.GenerativeModel(
            model_name="gemini-1.5-flash-002",
            system_instruction=system_instruction,
            generation_config=config
        )
        self.sql_chat = self.sql_model.start_chat(history=[])

class QuestionAsker(BaseClass):
    def __init__(self, system_instruction=question_asker_instruction):
        super().__init__(system_instruction, QuestionAskerResponseType)
        self.output = ""
    
    def ask_question(self, user_input=None):
        if user_input is None:
            self.output += "User: Hello i want to prepare a srs document.\n"
            response = self.sql_chat.send_message("Hello i want to prepare a srs document.")
        else:
            self.output += "User: " + user_input + "\n"
            response = self.sql_chat.send_message(user_input)
        
        response_json = json.loads(response.text)
        question = response_json.get("question")
        self.output += "CRO: " + question + "\n"
        keep_asking = response_json.get("hasQuestion", False)
        return question, keep_asking
    
class DocumentWriter(BaseClass):
    def __init__(self, system_instruction=document_writer_instruction):
        super().__init__(system_instruction, SRSWriterResponseType)
        
    def generate_output(self, output_cro):
        response = self.sql_chat.send_message(output_cro)
        response_json = json.loads(response.text)
        document = response_json.get("document")
        return document

class CodeWriter(BaseClass):
    def __init__(self, system_instruction=code_writer_instruction):
        super().__init__(system_instruction, None, is_json=False)
        
    def generate_output(self, output_cro):
        response = self.sql_chat.send_message(output_cro)
        print(f"Response of coder: \n{response.text}\n\n-------------------\n\n")
        if ("```python" in response.text):
            response_output = response.text.split("```python")[1].split("```")[0]
        else:
            return None
        return response_output
    
    

class Review(BaseClass):
    def __init__(self, system_instruction=reviewer_instruction):
        super().__init__(system_instruction, ReviewerResponseType)
        self.srs_preparer = CodeWriter()
        
    def generate_output(self, output_cro, needs_review=False, review_message=None,last_code=None,last_eval_output=None, reviewCount=0):
        
        if needs_review:
            output_cro = f"""
            
            Output of evulation: 
            
            {last_eval_output}
            
            Tester Agent: {review_message}
            
            """
           
        
        output = self.srs_preparer.generate_output(output_cro)
        
        if output is None:
            return last_code
        
        
        
        evulated = None
        evulate_errors = None
        try:
            evulated = exec(output)
            print(evulated)
        except Exception as e:
            print(e)
            evulate_errors = str(e)
        
        request_str = f"""
        code = ```python
        
        {output}
        
        ```
        
        # results
        
        evulated = {evulated}
        
        output_or_errors = {evulate_errors}
        
        """
        
        last_eval_output = f"""
        evulated = {evulated}
        
        output_or_errors = {evulate_errors}
        """
        
        print(request_str)
        
        
        response = self.sql_chat.send_message(request_str)
        response_json = json.loads(response.text)
        review_message = response_json.get("message")
        revision_required = response_json.get("revisionsRequired")
        if revision_required and reviewCount < 3:
            return self.generate_output(output_cro, True, review_message= review_message,last_code=output,last_eval_output=request_str, reviewCount=reviewCount+1)
        return output
        
    
# Instantiate the question asker agent    
question_asker = QuestionAsker()


def converse(user_input, chat_history=[]):
    # set history to genai if its not empty
    # if chat_history:
    #     chat_history = map_gradio_to_gpt_history(chat_history)
    if user_input == "":
        return "Please provide an input", chat_history
    
    question, keep_asking = question_asker.ask_question(user_input)
    print(f"Question: {question}")
    print(f"Keep Asking: {keep_asking}\n\n")
    if keep_asking:
        return question
    else:
        document_writer = DocumentWriter()
        document = document_writer.generate_output(question_asker.output)
        print(f"Document: {document}\n\n")
        srs_reviewer = Review()
        review_message = srs_reviewer.generate_output(document)
        
        tokens_of_question_asker = question_asker.sql_model.count_tokens(question_asker.sql_chat.history).total_tokens
        tokens_of_document_writer = document_writer.sql_model.count_tokens(document_writer.sql_chat.history).total_tokens
        tokens_of_srs_reviewer = srs_reviewer.sql_model.count_tokens(srs_reviewer.sql_chat.history).total_tokens
        tokens_of_code_writer = srs_reviewer.srs_preparer.sql_model.count_tokens(srs_reviewer.srs_preparer.sql_chat.history).total_tokens
        
        print(f"Tokens of Question Asker: {tokens_of_question_asker}")
        print(f"Tokens of Document Writer: {tokens_of_document_writer}")
        print(f"Tokens of Code Writer: {tokens_of_code_writer}")
        print(f"Tokens of Reviewer: {tokens_of_srs_reviewer}")
        print(f"Total number of tokens: {tokens_of_question_asker + tokens_of_document_writer + tokens_of_code_writer + tokens_of_srs_reviewer}")
        
        print(f"Final Review Message: \n\n{review_message}")
        
        
        return f"""
```python
        {review_message.strip()}\n
```
        """

interface = gr.ChatInterface(fn=converse, type="messages", examples=["I want you to create caesar cipher for both encrypt function and decrypt function"], title="Echo Bot")

if __name__ == "__main__":
    interface.launch()
